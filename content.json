{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"React学习","text":"useEffect是每次组件 render 完后判断依赖并执行 useCallback缓存一个函数123456789function Counter() { const [count, setCount] = useState(0); const handleIncrement = useCallback( () =&gt; setCount(count + 1), [count], // 只有当 count 发生变化时，才会重新创建回调函数 ); // ... return &lt;button onClick={handleIncrement}&gt;+&lt;/button&gt;} useMemo 缓存的是计算的结果123456789101112131415161718192021222324252627282930313233343536373839404142434445export default function SearchUserList() { const [users, setUsers] = useState(null); const [searchKey, setSearchKey] = useState(&quot;&quot;); useEffect(() =&gt; { const doFetch = async () =&gt; { // 组件首次加载时发请求获取用户数据 const res = await fetch(&quot;https://reqres.in/api/users/&quot;); setUsers(await res.json()); }; doFetch(); }, []); // let usersToShow = null; // if (users) { // // 无论组件为何刷新，这里一定会对数组做一次过滤的操作 // usersToShow = users.data.filter((user) =&gt; // user.first_name.includes(searchKey), // ); // } const usersToShow = useMemo(() =&gt; { if (!users) return null; return users.data.filter((user) =&gt; { return user.first_name.includes(searchKey); }) , [users, searchKey]); return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={searchKey} onChange={(evt) =&gt; setSearchKey(evt.target.value)} /&gt; &lt;ul&gt; {usersToShow &amp;&amp; usersToShow.length &gt; 0 &amp;&amp; usersToShow.map((user) =&gt; { return &lt;li key={user.id}&gt;{user.first_name}&lt;/li&gt;; })} &lt;/ul&gt; &lt;/div&gt; );} 使用useMemo当作useCallback()123456const myEventHandler = useMemo(() =&gt; { // 返回一个函数作为缓存结果 return () =&gt; { // 在这里进行事件处理 }}, [dep1, dep2]); useRef 在函数组件之外创建的一个容器空间 通过唯一的 current 属设置一个值，从而在函数组件的多次渲染之间共享这个值123456789101112131415161718192021222324252627export default function Timer() { // 定义 time state 用于保存计时的累积时间 const [time, setTime] = useState(0); // 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量 const timer = useRef(null); // 开始计时的事件处理函数 const handleStart = useCallback(() =&gt; { // 使用 current 属性设置 ref 的值 timer.current = window.setInterval(() =&gt; { setTime((time) =&gt; time + 1); }, 100); }, []); // 暂停计时的事件处理函数 const handlePause = useCallback(() =&gt; { // 使用 clearInterval 来停止计时 window.clearInterval(timer.current); timer.current = null; }, []); return ( &lt;div&gt; {time / 10} seconds. &lt;br /&gt; &lt;button onClick={handleStart}&gt;Start&lt;/button&gt; &lt;button onClick={handlePause}&gt;Pause&lt;/button&gt; &lt;/div&gt; );} useContext：定义全局状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const themes = { light: { foreground: &quot;#000000&quot;, background: &quot;#eeeeee&quot; }, dark: { foreground: &quot;#ffffff&quot;, background: &quot;#222222&quot; }};// 创建一个 Theme 的 Contextconst ThemeContext = React.createContext(themes.light);function App() { const [theme, setTheme] = useState(&quot;dark&quot;) const toggleTheme = () =&gt; { const newTheme = theme === 'dark' ? 'light': 'dark' setTheme(newTheme) } // 整个应用使用 ThemeContext.Provider 作为根组件 return ( // 使用 themes.dark 作为当前 Context &lt;ThemeContext.Provider value={themes[them]}&gt; &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );}// 在 Toolbar 组件中使用一个会使用 Theme 的 Buttonfunction Toolbar(props) { return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );}// 在 Theme Button 中使用 useContext 来获取当前的主题function ThemedButton() const theme = useContext(ThemeContext); return ( &lt;button style={{ background: theme.background, color: theme.foreground }}&gt; I am styled by theme context! &lt;/button&gt; );} 自定义hook使用use开头使用了其他hook定义useAsync12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export const useAsync = (asyncFunction: any) =&gt; { // 设置三个异步逻辑相关的 state const [data, setData] = useState&lt;any&gt;(null); const [loading, setLoading] = useState(false); const [error, setError] = useState(null); // 定义一个 callback 用于执行异步逻辑 const execute = useCallback(() =&gt; { // 请求开始时，设置 loading 为 true，清除已有数据和 error 状态 setLoading(true); setData(null); setError(null); return asyncFunction() .then((response: any) =&gt; { // 请求成功时，将数据写进 state，设置 loading 为 false setData(response); setLoading(false); }) .catch((error: any) =&gt; { // 请求失败时，设置 loading 为 false，并设置错误状态 setError(error); setLoading(false); }); }, [asyncFunction]); return { execute, loading, data, error };};export default function UserList() { // 定义获取用户的回调函数 const fetchUsers = async () =&gt; { const res = await fetch(&quot;https://reqres.in/api/users/&quot;); const result = await res.json(); return result.data // 请求成功后将用户数据放入 state }; const {execute, loading, data: users, error} = useAsync(fetchUsers) return ( &lt;div className=&quot;user-list&quot;&gt; &lt;button onClick={() =&gt; { execute() }} disabled={loading}&gt; {loading ? &quot;Loading...&quot; : &quot;Show Users&quot;} &lt;/button&gt; {error &amp;&amp; &lt;div style={{ color: &quot;red&quot; }}&gt;Failed: {String(error)}&lt;/div&gt; } &lt;br /&gt; &lt;ul&gt; {users &amp;&amp; users.length &gt; 0 &amp;&amp; users.map((user: any) =&gt; { return &lt;li key={user.id}&gt;{user.first_name}&lt;/li&gt;; })} &lt;/ul&gt; &lt;/div&gt; );} 自定义useForm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import { useCallback, useState } from &quot;react&quot;interface FormState { [key: string]: string}interface Validatetor { [key: string]: (value: string) =&gt; String | null}interface Errors { [key: string]: String | null}export const useForm = (initialState: FormState, validatetor: Validatetor) =&gt; { const [values, setValues] = useState(initialState) const [erros, setErros] = useState&lt;Errors&gt;({}) const setFileValues = useCallback((name: string, value: string)=&gt;{ setValues((values) =&gt; ( { ...values, [name]: value } )) setErros(erros =&gt; ({ ...erros, [name]: validatetor[name](value) })) }, []) return { values, erros, setFileValues }}export const MyForm = () =&gt; { const validators = useMemo(() =&gt; { return { name: (value: string) =&gt; { // 要求 name 的长度不得小于 2 if (value.length &lt; 2) return &quot;Name length should be no less than 2.&quot;; return null; }, email: (value: string) =&gt; { // 简单的实现一个 email 验证逻辑：必须包含 @ 符号。 if (!value.includes(&quot;@&quot;)) return &quot;Invalid email address&quot;; return null; }, }; }, []); const { values, erros, setFileValues } = useForm({}, validators) const handleSubmit = (e: FormEvent) =&gt; { e.preventDefault() console.log(values) } return ( &lt;form onSubmit={e =&gt; handleSubmit(e)}&gt; &lt;div&gt; &lt;label htmlFor=&quot;用户名&quot;&gt;&lt;/label&gt; &lt;input type=&quot;text&quot; value={values.name || ''} onChange={(e) =&gt; { setFileValues('name', e.target.value) }} /&gt; { erros.name &amp;&amp; &lt;div style={{color: 'red'}}&gt; {erros.name} &lt;/div&gt; } &lt;/div&gt; &lt;div&gt; &lt;label htmlFor=&quot;昵称&quot;&gt;&lt;/label&gt; &lt;input type=&quot;text&quot; value={values.email || ''} onChange={(e) =&gt; { setFileValues('email', e.target.value) }} /&gt; { erros.email &amp;&amp; &lt;div style={{color: 'red'}}&gt; {erros.email} &lt;/div&gt; } &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; )}","link":"/2022/09/19/React%E5%AD%A6%E4%B9%A0/"},{"title":"VSCode输出框中文乱码问题","text":"添加环境变量 1PYTHONIOENCODING=UTF8","link":"/2021/12/15/VSCode%E8%BE%93%E5%87%BA%E6%A1%86%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"go与java实现AES&#x2F;CBC&#x2F;NoPadding互通","text":"具体见正文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import ( &quot;bytes&quot; &quot;crypto/aes&quot; &quot;crypto/cipher&quot; &quot;encoding/base64&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;github.com/lxn/walk&quot; . &quot;github.com/lxn/walk/declarative&quot; &quot;strings&quot;)const ( ivParameter = &quot;abcdefghijklmnop&quot;)// 加密func PswEncrypt(src string, sKey string) string { key := []byte(sKey) iv := []byte(ivParameter) result, err := Aes128Encrypt([]byte(src), key, iv) if err != nil { panic(err) } return base64.RawStdEncoding.EncodeToString(result)}// 解密func PswDecrypt(src string, keyStr string) (string, error) { key := []byte(keyStr) iv := []byte(ivParameter) var result []byte var err error result, err = base64.StdEncoding.DecodeString(src) if err != nil { return &quot;&quot;, err } origData, err := Aes128Decrypt(result, key, iv) if err != nil { return &quot;&quot;, err } fmt.Println(string(origData)) index := strings.LastIndex(string(origData), &quot;}&quot;) return string(origData)[:index + 1], nil}func Aes128Encrypt(origData, key []byte, IV []byte) ([]byte, error) { if key == nil || len(key) != 16 { return nil, nil } if IV != nil &amp;&amp; len(IV) != 16 { return nil, nil } block, err := aes.NewCipher(key) if err != nil { return nil, err } blockSize := block.BlockSize() origData = PKCS5Padding(origData, blockSize) blockMode := cipher.NewCBCEncrypter(block, IV[:blockSize]) crypted := make([]byte, len(origData)) // 根据CryptBlocks方法的说明，如下方式初始化crypted也可以 blockMode.CryptBlocks(crypted, origData) return crypted, nil}func Aes128Decrypt(crypted, key []byte, IV []byte) ([]byte, error) { if key == nil || len(key) != 16 { return nil, nil } if IV != nil &amp;&amp; len(IV) != 16 { return nil, nil } block, err := aes.NewCipher(key) if err != nil { return nil, err } blockSize := block.BlockSize() blockMode := cipher.NewCBCDecrypter(block, IV[:blockSize]) origData := make([]byte, len(crypted)) blockMode.CryptBlocks(origData, crypted) origData = PKCS5UnPadding(origData) return origData, nil}func PKCS5Padding(ciphertext []byte, blockSize int) []byte { padding := blockSize - len(ciphertext)%blockSize padtext := bytes.Repeat([]byte{byte(padding)}, padding) return append(ciphertext, padtext...)}func PKCS5UnPadding(origData []byte) []byte { length := len(origData) // 去掉最后一个字节 unpadding 次 unpadding := int(origData[length-1]) return origData[:(length - unpadding)]}","link":"/2021/08/24/go%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0AES-CBC-NoPadding%E4%BA%92%E9%80%9A/"},{"title":"go在windows上打包成exe","text":"1. 新建 decrypt.exe.manifest(项目名 decrypt)123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;*&quot; name=&quot;SomeFunkyNameHere&quot; type=&quot;win32&quot;/&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.Windows.Common-Controls&quot; version=&quot;6.0.0.0&quot; processorArchitecture=&quot;*&quot; publicKeyToken=&quot;6595b64144ccf1df&quot; language=&quot;*&quot;/&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt; &lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt; &lt;windowsSettings&gt; &lt;dpiAwareness xmlns=&quot;http://schemas.microsoft.com/SMI/2016/WindowsSettings&quot;&gt;PerMonitorV2, PerMonitor&lt;/dpiAwareness&gt; &lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt;True&lt;/dpiAware&gt; &lt;/windowsSettings&gt; &lt;/application&gt;&lt;/assembly&gt; 2. 生成 decrypt.syso2.1 安装rsrchttps://github.com/akavel/rsrc/releases 2.2 生成decrypt.syso1rsrc -manifest decrypt.exe.manifest -ico favicon.ico -o decrypt.syso 3. 打包成exe文件1go build -ldflags=&quot;-H windowsgui -s -w&quot; 4. 压缩文件4.1 下载upx Releases · upx/upx (github.com) 4.2 压缩 1upx.exe -9 *.exe","link":"/2021/08/25/go%E5%9C%A8windows%E4%B8%8A%E6%89%93%E5%8C%85%E6%88%90exe/"},{"title":"go并发-Mutex使用","text":"Mutex最佳实践mutex 会嵌入到其他struct使用,如果嵌入的字段过多,会将Mutex放在控制的字段上面,然后使用空格将字段分隔出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;sync&quot;)func main() { var counter Counter var wg sync.WaitGroup for i := 0; i &lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() for j := 0; j &lt; 10000; j++ { counter.Incr() } }() } wg.Wait() fmt.Println(counter.Count())}// 线程安全的计数器type Counter struct { CounterType int Name string mu sync.Mutex count uint64}// 加1func (c *Counter) Incr() { c.mu.Lock() c.count++ c.mu.Unlock()}// 计数器的值func (c *Counter) Count() uint64 { c.mu.Lock() defer c.mu.Unlock() return c.count}","link":"/2021/09/28/go%E5%B9%B6%E5%8F%91-Mutex%E4%BD%BF%E7%94%A8/"},{"title":"go泛型","text":"使用 [] 定义泛型 1234567func SumInt64OrFloats[K comparable, V int64 | float64](m map[K]V) V { var s V for _, v := range m {​ s += v } return s} 使用 type12345678910111213type Number interface {​ int64 | float64}func SumInt64OrFloats[K comparable, V Number](m map[K]V) V { var s V for _, v := range m { s += v } return s} 使用泛型定义Stack1234567891011121314151617181920212223242526272829type stack [T any] []Tfunc (s *stack[T]) push(elem T) { *s = append(*s, elem)}func (s *stack[T]) pop() { if len(*s) &gt; 0 { *s = (*s)[:len(*s)-1] } }func (s *stack[T]) top() *T{ if len(*s) &gt; 0 { return &amp;(*s)[len(*s)-1] } return nil}func (s *stack[T]) len() int{ return len(*s)}func (s *stack[T]) print() { for _, elem := range *s { fmt.Print(elem) fmt.Print(&quot; &quot;) } fmt.Println(&quot;&quot;)} 使用泛型来实现map函数1234567891011121314151617181920212223242526func gMap[T1 any, T2 any] (arr []T1, f func(T1) T2) []T2 { result := make([]T2, len(arr)) for i, elem := range arr { result[i] = f(elem) } return result}nums := []int {0,1,2,3,4,5,6,7,8,9}squares := gMap(nums, func (elem int) int { return elem * elem})print(squares) //0 1 4 9 16 25 36 49 64 81 strs := []string{&quot;Hao&quot;, &quot;Chen&quot;, &quot;MegaEase&quot;}upstrs := gMap(strs, func(s string) string { return strings.ToUpper(s)})print(upstrs) // HAO CHEN MEGAEASE dict := []string{&quot;零&quot;, &quot;壹&quot;, &quot;贰&quot;, &quot;叁&quot;, &quot;肆&quot;, &quot;伍&quot;, &quot;陆&quot;, &quot;柒&quot;, &quot;捌&quot;, &quot;玖&quot;}strs = gMap(nums, func (elem int) string { return dict[elem]})print(strs) // 零 壹 贰 叁 肆 伍 陆 柒 捌 玖 使用泛型来实现reduce函数12345678910111213func gReduce[T1 any, T2 any] (arr []T1, init T2, f func(T2, T1) T2) T2 { result := init for _, elem := range arr { result = f(result, elem) } return result}nums := []int {0,1,2,3,4,5,6,7,8,9}sum := gReduce(nums, 0, func (result, elem int) int { return result + elem})fmt.Printf(&quot;Sum = %d \\n&quot;, sum) 使用泛型来实现filter函数123456789101112131415161718func gFilter[T any] (arr []T, in bool, f func(T) bool) []T { result := []T{} for _, elem := range arr { choose := f(elem) if (in &amp;&amp; choose) || (!in &amp;&amp; !choose) { result = append(result, elem) } } return result}func gFilterIn[T any] (arr []T, f func(T) bool) []T { return gFilter(arr, true, f)}func gFilterOut[T any] (arr []T, f func(T) bool) []T { return gFilter(arr, false, f)} 来源 Go编程模式 ： 泛型编程 | 酷 壳 - CoolShell","link":"/2022/01/24/go%E6%B3%9B%E5%9E%8B/"},{"title":"java图片添加文字&#x2F;图片水印","text":"读取要处理的图片12ClassPathResource resource = new ClassPathResource(&quot;template/clockbg.png&quot;);BufferedImage image = ImageIO.read(resource.getInputStream()); 创建画笔1Graphics2D pen = image.createGraphics(); 添加文字123pen.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 40));pen.setColor(Color.black);pen.drawString(timeContent, START_X, y); 添加网络图片12BufferedImage headImage = ImageIO.read(new URL(param.getImage()));pen.drawImage(headImage, START_X, y - INTERVAL_Y, 100, 100, null); 获取字体行数1234567private int getRowNum(String content) { int rowNum = content.length() / FONT_NUM; if (content.length() % FONT_NUM != 0) { rowNum ++; } return rowNum;} 文字区域换行1234567891011// 内容区域String content = &quot;恭喜您完成《&quot; + param.getTrainName() + &quot;》课程与认证。&quot;;int rowNum = getRowNum(content);for (int i = 0; i &lt; rowNum; i++) { if (i == rowNum - 1) { pen.drawString(content.substring(FONT_NUM * i), START_X, y); } else { pen.drawString(content.substring(FONT_NUM * i, FONT_NUM * (i + 1)), START_X, y); } y += INTERVAL_Y;} docker中添加中文字体123ADD yahei.ttf /usr/share/fonts/ttf-yahei/yahei.ttfRUN apk add fontconfig","link":"/2022/06/23/java%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%96%87%E5%AD%97/"},{"title":"js 其他","text":"axios12345678910111213141516171819202122232425262728293031import axios from 'axios'const baseUrl = &quot;http://localhost:4567&quot;&lt;!--more--&gt;// 创建 axios 的实例const instance = axios.create({ baseURL: baseUrl, timeout: 30000, headers: { Authorization: &quot;Bear mytoken&quot; }});instance.interceptors.request.use(function (config) { return config;}, function (error) { return Promise.reject(error);});instance.interceptors.response.use( (res) =&gt; { return res; }, (err) =&gt; { if (err.response.status === 401) { document.location = '/login'; } return Promise.reject(err); });export default instance","link":"/2022/09/21/js-%E5%85%B6%E4%BB%96/"},{"title":"koa体验","text":"1 安装1npm i koa 2 使用12345678const Koa = require('koa')const app = new Koa()app.use(async (ctx, next) =&gt; { await next(); ctx.response.type = 'text/html'; ctx.response.body = '&lt;h1&gt;Hello, koa2!&lt;/h1&gt;';})app.listen(3000) 3 使用路由中间件12345678910npm i koa-routerconst router = require('koa-router')()router.get('/hello/:name', async (ctx, next) =&gt; { const name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello, ${name}!&lt;/h1&gt;`;});app.use(router.routes()) 4 使用koa-bodyparser处理post请求1234567891011121314151617npm i koa-bodyparserconst bodyParser = require('koa-bodyparser');app.use(bodyParser());router.post('/signin', async (ctx, next) =&gt; { const name = ctx.request.body.name || '', password = ctx.request.body.password || ''; console.log(`signin with name: ${name}, password: ${password}`); if (name === 'koa' &amp;&amp; password === '12345') { ctx.response.body = `&lt;h1&gt;Welcome, ${name}!&lt;/h1&gt;`; } else { ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`; }}) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const Koa = require('koa');const router = require('koa-router')()const bodyParser = require('koa-bodyparser');const app = new Koa();app.use(bodyParser());// log request URL:app.use(async (ctx, next) =&gt; { console.log(`Process ${ctx.request.method} ${ctx.request.url}...`); await next();});app.use(async (ctx, next) =&gt; { await next(); ctx.response.type = 'text/html'; ctx.response.body = '&lt;h1&gt;Hello, koa2!&lt;/h1&gt;';})// add url-route:router.get('/hello/:name', async (ctx, next) =&gt; { const name = ctx.params.name; ctx.response.body = `&lt;h1&gt;Hello, ${name}!&lt;/h1&gt;`;});router.get('/', async (ctx, next) =&gt; { ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt; &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt; &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt; &lt;/form&gt;`;});router.post('/signin', async (ctx, next) =&gt; { const name = ctx.request.body.name || '', password = ctx.request.body.password || ''; console.log(`signin with name: ${name}, password: ${password}`); if (name === 'koa' &amp;&amp; password === '12345') { ctx.response.body = `&lt;h1&gt;Welcome, ${name}!&lt;/h1&gt;`; } else { ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`; }})app.use(router.routes())app.listen(3000)","link":"/2021/09/24/koa%E4%BD%93%E9%AA%8C/"},{"title":"maven安装jar到本地仓库","text":"安装jar到本地仓库1mvn install:install-file -Dfile=api.aliyun-0.0.1-SNAPSHOT.jar -DgroupId=com.peach -DartifactId=api.aliyun -Dversion=0.0.1-SNAPSHOT -Dpackaging=jar 发布到远程仓库-DgroupId: 组织名 -DartifactId: 项目名 -Dversion: 版本号 快照版本要带 SNAPSHOT 后缀 -Dpackaging: 打包方式 -Dfile：本地文件路径 -Durl: hosted类型的存储库url -DrepositoryId: 与maven的 settings.xml 文件里面配置的 标签下的相同。 1mvn deploy:deploy-file -DgroupId=com.test -DartifactId=tdd -Dversion=1.0.0 -Dpackaging=jar -Dfile=D:\\tdd\\tdd-1.0.0.jar -Durl=http://192.168.10.30:8081/repository/maven-releases/ -DrepositoryId=maven-releases settings.xml1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;maven-releases&lt;/id&gt; &lt;username&gt;xxxx&lt;/username&gt; &lt;password&gt;xxxx&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt;","link":"/2021/12/14/maven%E5%AE%89%E8%A3%85jar%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"},{"title":"mitmproxy使用","text":"安装1pip install mitmproxy 安装完就用 mitmproxy、mitmdump、mitmweb 三个命令可以使用 mitmproxy 主要是以控制台的方式交互 mitmdump 主要是以命令行的方式交互 mitmweb 以web形式交互 使用以mitmweb 使用为例，浏览器会打开8081端口，程序监听端口5000 1mitmweb -p 5000 start标签下 search是搜索 highlight高这 intercept拦截（这个写可以加断点） 加完断点后可以画笔修改请求和响应 运行浏览器进到浏览器目录 1**chrome.exe --proxy-server=127.0.0.1:8080 --ignore-certificate-errors** 使用代码控制1mitmweb -p 5000 -s test.py test.py (修改请求和响应) 12345678910111213141516171819202122232425from mitmproxy import ctxclass Counter(object): def __init__(self) -&gt; None: self.num = 0 def request(self, flow): # self.num = self.num + 1 # ctx.log.info(&quot;{} flows&quot;.format(str(self.num))) if flow.request.host != &quot;www.baidu.com&quot;: return # 修改查询参数 flow.request.query.set_all(&quot;wd&quot;, [&quot;最帅的人&quot;]) def response(self, flow): # self.num = self.num + 1 # flow.response.headers[&quot;count&quot;] = str(self.num) text = flow.response.get_text() text = text.replace(&quot;最帅的人&quot;,&quot;最帅的人 xxxx&quot;) flow.response.set_text(text)addons = [ Counter()]","link":"/2021/12/24/mitmproxy%E4%BD%BF%E7%94%A8/"},{"title":"mqtt","text":"简介MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 使用docker安装mqtt服务 emqx1docker run -d --name emqx -p 18083:18083 -p 1883:1883 emqx:4.4 访问控制界面 http://localhost:18083 admin/public 使用spring mqttMQTT Support (spring.io) 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt; &lt;artifactId&gt;spring-integration-mqtt&lt;/artifactId&gt;&lt;/dependency&gt; inboud(收消息)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SpringBootApplicationpublic class MqttJavaApplication { public static void main(String[] args) { new SpringApplicationBuilder(MqttJavaApplication.class) .web(false) .run(args); } @Bean public MqttConnectOptions getMqttConnectOptions() { MqttConnectOptions mqttConnectOptions = new MqttConnectOptions(); mqttConnectOptions.setUserName(&quot;&quot;); mqttConnectOptions.setPassword(&quot;&quot;.toCharArray()); mqttConnectOptions.setServerURIs(new String[]{hostUrl}); return mqttConnectOptions; } @Bean public MqttPahoClientFactory mqttClientFactory() { DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory(); factory.setConnectionOptions(getMqttConnectOptions()); return factory; } @Bean public MessageChannel mqttInputChannel() { return new DirectChannel(); } @Bean public MessageProducer inbound() { MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter( &quot;testClient&quot;, mqttClientFactory(), topic1&quot;, &quot;topic2&quot;); adapter.setCompletionTimeout(5000); adapter.setConverter(new DefaultPahoMessageConverter()); adapter.setQos(1); adapter.setOutputChannel(mqttInputChannel()); return adapter; } @Bean @ServiceActivator(inputChannel = &quot;mqttInputChannel&quot;) public MessageHandler handler() { return new MessageHandler() { @Override public void handleMessage(Message&lt;?&gt; message) throws MessagingException { System.out.println(message.getPayload()); } }; }} outbound(发消息)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@SpringBootApplication@IntegrationComponentScanpublic class MqttJavaApplication { public static void main(String[] args) { ConfigurableApplicationContext context = new SpringApplicationBuilder(MqttJavaApplication.class) .web(false) .run(args); MyGateway gateway = context.getBean(MyGateway.class); gateway.sendToMqtt(&quot;foo&quot;); } @Bean public MqttPahoClientFactory mqttClientFactory() { DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory(); MqttConnectOptions options = new MqttConnectOptions(); options.setServerURIs(new String[] { &quot;tcp://host1:1883&quot;, &quot;tcp://host2:1883&quot; }); options.setUserName(&quot;username&quot;); options.setPassword(&quot;password&quot;.toCharArray()); factory.setConnectionOptions(options); return factory; } @Bean @ServiceActivator(inputChannel = &quot;mqttOutboundChannel&quot;) public MessageHandler mqttOutbound() { MqttPahoMessageHandler messageHandler = new MqttPahoMessageHandler(&quot;testClient&quot;, mqttClientFactory()); messageHandler.setAsync(true); messageHandler.setDefaultTopic(&quot;testTopic&quot;); return messageHandler; } @Bean public MessageChannel mqttOutboundChannel() { return new DirectChannel(); } @MessagingGateway(defaultRequestChannel = &quot;mqttOutboundChannel&quot;) public interface MyGateway { void sendToMqtt(String data); void sendToMqtt(String data,@Header(MqttHeaders.TOPIC) String topic); /** * 发送信息到MQTT服务器 * * @param topic 主题 * @param qos 对消息处理的几种机制。 * 0 表示的是订阅者没收到消息不会再次发送，消息会丢失。 * 1 表示的是会尝试重试，一直到接收到消息，但这种情况可能导致订阅者收到多次重复消息。 * 2 多了一次去重的动作，确保订阅者收到的消息有一次。 * @param payload 消息主体 */ void sendToMqtt(@Header(MqttHeaders.TOPIC) String topic, @Header(MqttHeaders.QOS) int qos, String payload); }} 测试客户端MQTT Explorer","link":"/2022/05/29/mqtt/"},{"title":"mysql中使用json","text":"创建表123456789101112CREATE TABLE `dept` ( `id` int(11) NOT NULL, `dept` varchar(255) DEFAULT NULL, `json_value` json DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into dept VALUES(1,'部门1','{&quot;deptName&quot;: &quot;部门1&quot;, &quot;deptId&quot;: &quot;1&quot;, &quot;deptLeaderId&quot;: &quot;3&quot;}');insert into dept VALUES(2,'部门2','{&quot;deptName&quot;: &quot;部门2&quot;, &quot;deptId&quot;: &quot;2&quot;, &quot;deptLeaderId&quot;: &quot;4&quot;}');insert into dept VALUES(3,'部门3','{&quot;deptName&quot;: &quot;部门3&quot;, &quot;deptId&quot;: &quot;3&quot;, &quot;deptLeaderId&quot;: &quot;5&quot;}');insert into dept VALUES(4,'部门4','{&quot;deptName&quot;: &quot;部门4&quot;, &quot;deptId&quot;: &quot;4&quot;, &quot;deptLeaderId&quot;: &quot;5&quot;}');insert into dept VALUES(5,'部门5','{&quot;deptName&quot;: &quot;部门5&quot;, &quot;deptId&quot;: &quot;5&quot;, &quot;deptLeaderId&quot;: &quot;5&quot;}'); 使用 字段名称 -&gt; ‘$.属性’1select * from dept where json_value -&gt; '$.deptName' = '部门1' 字段名称去掉 ‘’ -&gt;&gt;1select json_value -&gt;&gt; '$.deptName' from dept 关联 1SELECT * from dept,dept_leader WHERE dept.json_value-&gt;'$.deptLeaderId'=dept_leader.json_value-&gt;'$.id' ; 提取字段1select id,json_extract(json_value,'$.deptName') as deptName from dept; 包含1select * from dept WHERE JSON_CONTAINS(json_value, JSON_OBJECT(&quot;deptName&quot;,&quot;部门5&quot;)) json_object 转成jsonjson_array 转成 json_array函数JSON_KEYS() ：JSON文档中的键数组1SELECT JSON_KEYS(json_value) FROM dept 函数JSON_SET() ：将数据插入JSON格式中，有key则替换，无key则新增1update dept set json_value=JSON_SET('{&quot;deptName&quot;: &quot;部门2&quot;, &quot;deptId&quot;: &quot;2&quot;, &quot;deptLeaderId&quot;: &quot;4&quot;}','$.deptName','新增的部门1','$.newData','新增的数据') WHERE id=2;","link":"/2022/01/18/mysql%E4%B8%AD%E4%BD%BF%E7%94%A8json/"},{"title":"paramiko简单封装","text":"安装1pip install paramiko 使用123456789101112import paramiko class SSH(object): def __init__(self, host: str, port: int, username: str, password=None, key_path=None): self.host = host self.port = port self.username = username self.password = password self.key_path = key_path self.ssh: paramiko.client.SSHClient = None self.sftp: paramiko.SFTPClient = None def connect(self): self.ssh = paramiko.SSHClient() # 设置信任远程机器，允许访问 self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) transport = paramiko.Transport((self.host, self.port)) if self.password: self.ssh.connect(hostname=self.host, port=self.port, username=self.username, password=self.password) transport.connect(username=self.username, password=self.password) else: private_key = paramiko.RSAKey.from_private_key_file(self.key_path) self.ssh.connect(hostname=self.host, port=self.port, username=self.username, pkey=private_key) transport.connect(username=self.username, pkey=private_key) self.sftp = paramiko.SFTPClient.from_transport(transport) def execute(self, order: str): return self.ssh.exec_command(order) def put(self, src_path: str, dest_path: str): self.sftp.put(src_path, dest_path) def get(self, src_path: str, dest_path: str): self.sftp.get(src_path, dest_path) 12345678910111213if __name__ == '__main__': ssh = SSH(host='host', port=22, username='username', key_path='') ssh.connect() stdin, stdout, stderr = ssh.execute('ls') print(str(stdout.read())) print(str(stderr.read())) # # for line in stdout: # print('stdout', line.strip(&quot;\\n&quot;)) # for line in stderr: # print('err', line.strip(&quot;\\n&quot;)) ssh.put('./hello.txt', '/opt/hello.txt') ssh.get('/opt/hello.txt', 'd:/hello.txt')","link":"/2022/08/22/paramiko%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/"},{"title":"python使用pyinstaller打包成exe","text":"使用虚拟环境使打包后exe体积变小 安装1pip install pyinstaller 打包-F 独立应用 -w 不要控制台 -i 图标 1Pyinstaller -F -w -i apple.ico .\\demo.py","link":"/2021/12/29/python%E4%BD%BF%E7%94%A8pyinstaller%E6%89%93%E5%8C%85%E6%88%90exe/"},{"title":"react-hooks的优势","text":"逻辑复用使用传统的 123456789101112131415161718192021222324252627282930313233343536373839404142const withWindowSize = Component =&gt; { // 产生一个高阶组件 WrappedComponent，只包含监听窗口大小的逻辑 class WrappedComponent extends React.PureComponent { constructor(props) { super(props); this.state = { size: this.getSize() }; } componentDidMount() { window.addEventListener(&quot;resize&quot;, this.handleResize); } componentWillUnmount() { window.removeEventListener(&quot;resize&quot;, this.handleResize); } getSize() { return window.innerWidth &gt; 1000 ? &quot;large&quot; : &quot;small&quot;; } handleResize = () =&gt; { const currentSize = this.getSize(); this.setState({ size: this.getSize() }); } render() { // 将窗口大小传递给真正的业务逻辑组件 return &lt;Component size={this.state.size} /&gt;; } } return WrappedComponent;};class MyComponent extends React.Component { render() { const { size } = this.props; if (size === &quot;small&quot;) return &lt;SmallComponent /&gt;; else return &lt;LargeComponent /&gt;; }}// 使用 withWindowSize 产生高阶组件，用于产生 size 属性传递给真正的业务组件export default withWindowSize(MyComponent); 使用hooks12345678910111213141516171819202122const getSize = () =&gt; { return window.innerWidth &gt; 1000 ? &quot;large&quot; : &quot;small&quot;;}const useWindowSize = () =&gt; { const [size, setSize] = useState(getSize()); useEffect(() =&gt; { const handler = () =&gt; { setSize(getSize()) }; window.addEventListener('resize', handler); return () =&gt; { window.removeEventListener('resize', handler); }; }, []); return size;};const Demo = () =&gt; { const size = useWindowSize(); if (size === &quot;small&quot;) return &lt;SmallComponent /&gt;; else return &lt;LargeComponent /&gt;;}; 有助于关注分离代码逻辑写在一起","link":"/2022/09/19/react-hooks%E7%9A%84%E4%BC%98%E5%8A%BF/"},{"title":"react router","text":"react router V6安装1npm i react-router-dom 使用123456789101112131415161718192021222324import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'&lt;Router&gt; &lt;Routes&gt; &lt;Route path={&quot;/&quot;} element={&lt;App /&gt;} &gt; &lt;Route path={&quot;invoices&quot;} element={&lt;Invoices /&gt;} &gt; // index类型route,当没有任何选中的时候展示这个 &lt;Route index element={ &lt;div&gt; select a invoice &lt;/div&gt; }/&gt; &lt;Route path=':invoiceId' element={&lt;Invoice/&gt;}/&gt; &lt;/Route&gt; &lt;Route path={&quot;expenses&quot;} element={&lt;Expenses /&gt;} /&gt; &lt;/Route&gt; // 404所有的不匹配的时候展示 &lt;Route path={&quot;*&quot;} element={ &lt;div&gt; not found &lt;/div&gt; } /&gt; &lt;/Routes&gt; &lt;/Router&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import { Outlet, NavLink, useSearchParams } from 'react-router-dom'import { getInvoices } from &quot;./data&quot;export default function Invoices() { const invoices = getInvoices() // 获取的是url参数 ?后面的参数 const [searchParams, setSearchParams] = useSearchParams() return ( &lt;div style={{ display: 'flex', flexDirection: 'column' }}&gt; &lt;input type=&quot;text&quot; value={searchParams.get('filter') || &quot;&quot;} onChange={(e) =&gt; { let filter = e.target.value if (filter) { setSearchParams({filter}) } else { setSearchParams({}) } }} /&gt; &lt;nav style={{ padding: '1rem', borderRight: &quot;solid 1px&quot;, marginRight: &quot;2rem&quot; }}&gt; { invoices .filter(invoice =&gt; { let value = searchParams.get('filter') if (!value) { return true } return invoice.name.startsWith(value) }) .map((invoice) =&gt; ( &lt;NavLink style={({ isActive }) =&gt; ({ display: &quot;block&quot;, margin: &quot;1rem 0&quot;, color: isActive ? &quot;red&quot; : &quot;&quot; })} to={`/invoices/${invoice.number}`} key={invoice.number} &gt; {invoice.name} &lt;/NavLink&gt; )) } &lt;/nav&gt; &lt;Outlet /&gt; &lt;/div&gt; );} 12345678910111213141516171819import { useParams } from 'react-router-dom'import { getInvoice } from './data'export default function Invoice() { // 获取路径参数 let params = useParams() let invoice = getInvoice(parseInt(params.invoiceId || &quot;1&quot;)) return ( &lt;div&gt; &lt;h2&gt;Invoice {params.invoiceId}&lt;/h2&gt; &lt;p&gt; {invoice?.name}: {invoice?.number} &lt;/p&gt; &lt;p&gt;Due Date: {invoice?.due}&lt;/p&gt; &lt;/div&gt; )}","link":"/2022/09/25/react-router%E4%BD%BF%E7%94%A8/"},{"title":"redis中lua脚本使用","text":"Redis中Lua的常用命令- EVAL- EVALSHA- SCRIPT LOAD - SCRIPT EXISTS- SCRIPT FLUSH- SCRIPT KILL EVAL 使用EVAL script numkeys key [key …] arg [arg …] 1个key 1EVAL &quot;return KEYS[1]&quot; 1 key1 0 个key 1EVAL &quot;return ARGV[1]&quot; 0 value1 多个key和多个arguments 1eval &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second 使用redis.call() 先执行SET命令，在执行EXPIRE命令 1EVAL &quot;redis.call('SET', KEYS[1], ARGV[1]);redis.call('EXPIRE', KEYS[1], ARGV[2]); return 1;&quot; 1 userAge 10 60","link":"/2022/01/17/redis%E4%B8%ADlua%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"redux-toolkit使用","text":"安装 npm i @reduxjs/toolkit创建store1234567891011121314import { configureStore } from '@reduxjs/toolkit'import CounterReducer from './counter.slice'export const store = configureStore({ reducer: { counter: CounterReducer },})// Infer the `RootState` and `AppDispatch` types from the store itselfexport type RootState = ReturnType&lt;typeof store.getState&gt;// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}export type AppDispatch = typeof store.dispatch 创建slice12345678910111213141516171819202122232425262728293031import { createSlice } from '@reduxjs/toolkit'import { PayloadAction, createAsyncThunk } from '@reduxjs/toolkit'export interface CounterState { value: number}const initialState: CounterState = { value: 0,}export const counterSlice = createSlice({ name: 'counter', initialState, reducers: { increment: (state) =&gt; { state.value += 1 }, decrement: (state) =&gt; { state.value -= 1 }, incrementByAmount: (state, action: PayloadAction&lt;number&gt;) =&gt; { state.value += action.payload }, },})// Action creators are generated for each case reducer functionexport const { increment, decrement, incrementByAmount } = counterSlice.actionsexport default counterSlice.reducer 使用根组件12345678910111213import React from 'react'import ReactDOM from 'react-dom/client'import App from './App'import {Provider } from 'react-redux'import {store} from './store'ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render( &lt;React.StrictMode&gt; &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;) 子组件1234567891011121314151617181920212223242526272829import { useDispatch, useSelector } from 'react-redux'import { RootState } from './store'import { increment, decrement, incrementByAmount, incrementAsync } from './counter.slice'function App() { // 使用值 const count = useSelector((state: RootState) =&gt; state.counter.value) // 触发 const dispatch = useDispatch() return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;card&quot;&gt; &lt;button onClick={() =&gt; { dispatch(increment()) }}&gt; + &lt;/button&gt; &lt;button onClick={() =&gt; { dispatch(decrement()) }}&gt; - &lt;/button&gt; &lt;button onClick={() =&gt; { dispatch(incrementByAmount(10)) }}&gt; +10 &lt;/button&gt; &lt;div&gt; count is {count} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )}","link":"/2022/09/23/redux-toolkit%E4%BD%BF%E7%94%A8/"},{"title":"feign集成sentinel和resilience4j使用","text":"集成sentinel文档地址 Sentinel · alibaba/spring-cloud-alibaba Wiki (github.com) 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置 1feign.sentinel.enabled=true 添加fallback 12345678910111213141516171819@FeignClient(name = &quot;service-provider&quot;, fallback = EchoServiceFallback.class, configuration = FeignConfiguration.class)public interface EchoService { @RequestMapping(value = &quot;/echo/{str}&quot;, method = RequestMethod.GET) String echo(@PathVariable(&quot;str&quot;) String str);}class FeignConfiguration { @Bean public EchoServiceFallback echoServiceFallback() { return new EchoServiceFallback(); }}class EchoServiceFallback implements EchoService { @Override public String echo(@PathVariable(&quot;str&quot;) String str) { return &quot;echo fallback&quot;; }} 集成resilience4j 文档地址 Spring Cloud Circuit Breaker Getting Started (readme.io) 非响应式 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;&lt;/dependency&gt; 响应式 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; 3. 配置 4. 见上面","link":"/2021/12/28/sentinel%E5%92%8Cresilience4j%E4%BD%BF%E7%94%A8/"},{"title":"Vertx基础","text":"响应json, 需要安装jackson12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.4&lt;/version&gt;&lt;/dependency&gt;router .get(&quot;/some/path&quot;) // 这个处理器将保证这个Pojo会被序列化成json // content type被设置成 &quot;application/json&quot; .respond( ctx -&gt; Future.succeededFuture(new Pojo()));或者ctx.json(new Todo()); 使用阻塞式处理器123456router.route().blockingHandler(ctx -&gt; { // 执行某些同步的耗时操作 service.doSomethingThatBlocks(); // 调用下一个处理器 ctx.next();}); 精确路由123456789Route route = router.route().path(&quot;/some/path/&quot;);会匹配// `/some/path/`// `/some/path//`Route route2 = router.route().path(&quot;/some/path&quot;);会匹配// `/some/path`// `/some/path/`// `/some/path//` 路径参数1ctx.pathParam(&quot;productType&quot;); 重定向1ctx.redirect(&quot;https://wwww.baidu.com&quot;); 重定向到某个路由上去1ctx.reroute(&quot;/some/path/B&quot;) 错误处理123456789Route route = router.route(&quot;/*&quot;);route.failureHandler(failureRoutingContext -&gt; { int statusCode = failureRoutingContext.statusCode(); // RuntimeException的状态码将为500 // 或403，表示其他失败 HttpServerResponse response = failureRoutingContext.response(); response.setStatusCode(statusCode).end(&quot;Sorry! Not today&quot;);}); 使用session1234567891011SessionStore store = LocalSessionStore.create(vertx);SessionHandler sessionHandler = SessionHandler.create(store);// 确保所有请求都可以路由经过这个session处理器router.route().handler(sessionHandler);// 现在您的应用程序可以开始处理了router.route(&quot;/somepath/blah/&quot;).handler(ctx -&gt; { Session session = ctx.session(); session.put(&quot;foo&quot;, &quot;bar&quot;); // 等等}); 静态文件123router.route(&quot;/static/*&quot;).handler(StaticHandler.create());将访问的是resources/webroot下的文件","link":"/2022/10/10/Vertx%E5%9F%BA%E7%A1%80/"},{"title":"shell学习","text":"set -e #遇到错误不继续执行, 默认是set +e,遇到错误继续执行echo用法是否使用双引号区别:使用双引号原样输出,不使用双引号会去除多余空格1echo hello world 你好 outout:hello world 你好 对于变量同样有用 -n: 不换行, echo默认有换行-e:能执行转义字符输出带颜色的字符 declare用法,同义词 set, 相反 unset-i 整形 -r只读-a数组 -f指定函数名 ``反引号和$() 1234local_ip=`cat /etc/hosts | grep \\`hostname\\` | awk '{print $1}'`local_ip2=$(cat /etc/hosts | grep `hostname` | awk '{print $1}')echo $local_ipecho $local_ip2 数组定义 arr=(1 2 abc “hello world”)使用*或@代表整个数组, #代表数组的长度, 不写是第一个元素1234echo &quot;${#arr[@]}&quot;echo &quot;${#arr[*]}&quot;echo # 数组的遍历 # 方式一 1234567891011index=1for ele in &quot;${arr[@]}&quot;do echo &quot;第${index}个元素是:$ele&quot; count=`expr $index + 1`done echo “方式二—————“ 123456789for i in `seq 0 ${last_index}`do pos=`expr $i + 1` echo &quot;第$pos个元素是${arr[$i]}&quot;done 函数定义: func1(){}长度: $#返回值:$?12345678910111213141516171819func_with_params() { echo &quot;参数长度:$#&quot; # 打印所有的参数 for i in `seq 1 $#` # seq 1 $#代表是 1到数组的长度 do echo &quot;第$i个元素是:$1&quot; shift #这个作用是将参数挪到前面 done}func_with_params xx yy zz 计算 expr let (())@ 和*的区别arr=(1 2 3) for ele in “${arr[@]}” // 正常输出 for ele in “${arr[*]}” // 数组是一个整体 1 文件描述符0 标准输入 1 标准输出 2 标准错误输出","link":"/2022/05/03/shell%E5%AD%A6%E4%B9%A0/"},{"title":"typescript","text":"初始化工程12npm init -ytsc --init 安装依赖12npm install -D ts-nodenpm install typescript -D typescript知识Pick&lt;T, U&gt;：从T中提取U属性，返回取到的所有属性123456interface Person { name: string age: number height: number}type Person1 = Pick&lt;Person, 'age' | 'height'&gt; // 等价于 type Person1 ={name: string, height: number} Omit&lt;T, U&gt; ：从T中剔除掉U属性，返回剩下的所有属性。1type Person2 = Omit&lt;Person, 'name'&gt; // 等价于 type Person2 ={age: number, height: number} Record&lt;K , T&gt;：把T变成K的所有属性的值类型。123456789101112131415interface PageInfo { title: string; description: string;}type Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;type TypeTodo1 = Record&lt;Page, PageInfo&gt; // 等价于 type TypeTodo1 = { home: PageInfo, about: PageInfo, contact: PageInfo}type perf = Record&lt;string, any&gt;;//会被编译成下面的 perf1 // 等价于type perf1 = { [x: string]: any;} Exclude&lt;T, U&gt; ：从T中剔除可以赋值给U的类型。1type E = Exclude&lt;string | number, string&gt; Extract&lt;T, U&gt; ：提取T中可以赋值给U的类型。1type I = Extract&lt;string | number, string&gt;; Partial ：返回所有属性变成可选的，即属性可传可不传。12345type Animal = { species: string; age: number;}type Cat = Partial&lt;Animal&gt; // 等价于 type Cat ={ species?: string | undefined, age?: number | undefined } keyof T ：获取 T上已知的公共属性名的联合。1234type Dog = keyof Animal; // 'species' | 'age'let dog: Dog = &quot;species&quot;; //编译成功let dog1: Dog = &quot;age&quot;; //编译成功// let dog2: Dog = &quot;name&quot;; //编译失败 不能将类型“&quot;name&quot;”分配给类型“keyof Animal”。 NonNullable ： 从T中剔除null和undefined1234type N = NonNullable&lt;string | number | undefined | null&gt;; // 删除null和undifined;let nm: N = 111; // 编译成功let nm1: N = '1112'; //编译成功// let nm2: N = null; //编译失败 ReturnType：获取函数返回值类型12345678910function getUserInfo(name: string, age: number) { return { name, age };}// ReturnType获取函数返回值type UserInfo = ReturnType&lt;typeof getUserInfo&gt;; //{ name: string; age: number; }const userA: UserInfo = { name: &quot;zhufeng&quot;, age: 10,}; //编译成功 Parameters ：获取函数所有参数的类型元组1type T1 = Parameters&lt;typeof getUserInfo&gt;;// [name: string, age: number] InstanceType ： 获取构造函数类型的实例类型12345678class Poit { x: number = 0; y: string = '';}type T20 = InstanceType&lt;typeof Poit&gt;; // { x:number; y:string };let T2: T20 = { x: 111, y: '1111' };","link":"/2022/09/21/typescript/"},{"title":"vscode 无法自动补全第三方库","text":"首选项-&gt;设置-&gt;扩展-&gt;python-&gt;在settins.sjon中编辑添加 12345&quot;python.autoComplete.extraPaths&quot;: [ &quot;${workspaceFolder}/venv/lib/site-packages&quot; ] ${workspaceFolder}/venv/lib/site-packages 为本地虚拟路的路径","link":"/2021/12/16/vscode-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"title":"抓取豆瓣250条数据","text":"抓取豆瓣250条数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&quot;&quot;&quot;抓取豆瓣250条数据pip install beautifulsoup4pip install lxmlpip install requests&quot;&quot;&quot;import requestsfrom bs4 import BeautifulSoupclass Movie(object): def __init__(self, no, title, pic, rate, url): self.no = no self.title = title self.pic = pic self.rate = rate self.url = url def __str__(self): return &quot;{}\\t{}\\t{}\\t{}\\t{}&quot;.format(self.no, self.title, self.pic, self.rate, self.url)def fetch(url): headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &quot; &quot;Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.57 &quot; } try: response = requests.get(url, headers=headers) if response.status_code == 200: return response.text except Exception as e: print(e) return Nonedef parse(html: str): bs = BeautifulSoup(html, &quot;lxml&quot;) items = bs.select(&quot;div.item&quot;) l = [] for item in items: no = item.select_one(&quot;.pic em&quot;).text title = item.select_one(&quot;.info .title&quot;).text pic = item.select_one(&quot;.pic img&quot;).attrs[&quot;src&quot;] rate = item.select_one(&quot;.info .rating_num&quot;).text url = item.select_one(&quot;.pic a&quot;).attrs[&quot;href&quot;] # print(no, tittle, pic, rate, url) l.append(Movie(no, title, pic, rate, url)) return ldef save_to_text(movies): with open(&quot;./movies.txt&quot;, &quot;w&quot;, encoding=&quot;utf8&quot;) as f: str = &quot;&quot; for movie in movies: str += movie.__str__() + &quot;\\n&quot; f.write(str) if __name__ == &quot;__main__&quot;: all_movies = [] for i in range(0, 10): url = &quot;&quot; if i == 0: url = &quot;https://movie.douban.com/top250&quot; else: url = &quot;https://movie.douban.com/top250?start={}&quot;.format(str(25 * i)) result = fetch(url) if result: moviles = parse(result) all_movies.extend(moviles) save_to_text(all_movies)","link":"/2021/12/20/%E6%8A%93%E5%8F%96%E8%B1%86%E7%93%A3250%E6%9D%A1%E6%95%B0%E6%8D%AE/"},{"title":"使用hexo安装博客","text":"初始化123hexo init blogcd bloghexo s == hexo server 进行预览 修改中文语言12修改 _config.ymllanguage: zh-CN 安装主题123git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus修改 _config.yml theme: icarus可能会报错,根据提示安装 部署,使用username.github.io进行访问123456781. 安装deploy插件npm install hexo-deployer-git --save2. 配置_config.ymldeploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master3. hexo d 自定义域名121. 域名解析,添加一条CNAME记录, 值埴上&lt;username&gt;.github.io2. 进入到&lt;username&gt;.githut.io.git项目中,Settings-&gt;Pages页面找到Custom domain填上你的域名,校验完后Enforce HTTPS 最后一步1source目录下新建CNAME的文件,内容填上你的自定义域名(xxxx.yyy),重新推送一次 添加分类 2021-08-2412345678910111213141. hexo new page categories2. 修改成 /source/categories/index.md---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;---3. 在文章上加上---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端---","link":"/2021/08/21/%E4%BD%BF%E7%94%A8hexo%E5%AE%89%E8%A3%85%E5%8D%9A%E5%AE%A2/"},{"title":"wsl2配置","text":"wsl2 ping不通宿主机powershell以管理员身份执行，关闭wsl网卡防火墙 1New-NetFirewallRule -DisplayName &quot;WSL&quot; -Direction Inbound -InterfaceAlias &quot;vEthernet (WSL)&quot; -Action Allow wsl2 配置宿主机代理123456789vim /etc/profile (zsh是~/.zshrc)## 获取主机 IP## 主机 IP 保存在 /etc/resolv.conf 中export hostip=$(cat /etc/resolv.conf |grep -oP '(?&lt;=nameserver\\ ).*')## 配置socks代理export all_proxy=&quot;socks5://${hostip}:1080&quot;source /etc/profile 端口转发(wsl2中的跑的服务能通过局域网访问)12345netsh interface portproxy add v4tov4 listenport=【宿主机windows平台监听端口】 listenaddress=0.0.0.0 connectport=【wsl2平台监听端口】 connectaddress=【wsl2平台ip】protocol=tcp示例netsh interface portproxy add v4tov4 listenport=9000 listenaddress=0.0.0.0 connectport=9000 connectaddress=172.21.47.103 protocol=tcp","link":"/2021/11/11/wsl2%E9%85%8D%E7%BD%AE/"},{"title":"运行python脚本提示 ModuleNotFoundError: No module named","text":"添加环境变量 1PYTHONPATH=python代码所在路径","link":"/2021/12/15/%E8%BF%90%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%E6%8F%90%E7%A4%BA-ModuleNotFoundError-No-module-named/"}],"tags":[{"name":"react","slug":"react","link":"/tags/react/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"js axios","slug":"js-axios","link":"/tags/js-axios/"},{"name":"koa","slug":"koa","link":"/tags/koa/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"mqtt, java","slug":"mqtt-java","link":"/tags/mqtt-java/"},{"name":"mysql json","slug":"mysql-json","link":"/tags/mysql-json/"},{"name":"paramiko python","slug":"paramiko-python","link":"/tags/paramiko-python/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"react hooks","slug":"react-hooks","link":"/tags/react-hooks/"},{"name":"react-router","slug":"react-router","link":"/tags/react-router/"},{"name":"redis lua","slug":"redis-lua","link":"/tags/redis-lua/"},{"name":"redux redux-toolkit","slug":"redux-redux-toolkit","link":"/tags/redux-redux-toolkit/"},{"name":"vertx java","slug":"vertx-java","link":"/tags/vertx-java/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"vscode python","slug":"vscode-python","link":"/tags/vscode-python/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"wsl2","slug":"wsl2","link":"/tags/wsl2/"}],"categories":[{"name":"go","slug":"go","link":"/categories/go/"},{"name":"koa","slug":"koa","link":"/categories/koa/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"}]}